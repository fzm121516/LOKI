import os
import json
import random

import pandas as pd

from collections import Counter, defaultdict

TRUE_FALSE_PROMPT = "<image>\n" + "You have been shown one image, possibly generated by AI. \nPlease identify whether this image is generated by AI or not. \nAnswer yes or no first. Then, if you think the image is generated by AI, state your reasons.\n"

QUESTION_REAL = "<image>\n" * 2 + "You have been shown two different images. One of the images is generated by AI. Which of the above images is most likely generated by AI?"

QUESTION_FAKE = "<image>\n" * 2 + "You have been shown two different images. One of the images is not generated by AI. Which of the above images is most likely not generated by AI?"

OPTIONS = ["The first one.", "The second one.", "The third one.", "The fourth one."]

OPTION_LETTERS = ["A", "B", "C", "D"]

data_list = json.load(open('/mnt/petrelfs/zhoubaichuan/projects/synthbench/data/synthbench_image_meta.json', 'r'))

type_counter = Counter()

def generate_tf_questions(data, num_questions=700):
    real_images = [image for image in data if not image['is_fake']]
    fake_images = [image for image in data if image['is_fake']]

    questions_real = []
    questions_fake = []
    
    sampled_real_images = random.sample(real_images, num_questions)
    sampled_fake_images = random.sample(fake_images, num_questions)

    for i in range(num_questions):
        real_sample = sampled_real_images[i]
        fake_sample = sampled_fake_images[i]
        
        fake_type = fake_sample['image_type']
        real_type = real_sample['image_type']

        questions_real.append({'image_path': real_sample['image_path'], 'question': TRUE_FALSE_PROMPT, 'answer': 'No', 'modality': 'image-text', 'metric': 'open-ended', 'question_type': f'image_fake_or_real_{real_type}_open_ended', 'choices': []})
        questions_fake.append({'image_path': fake_sample['image_path'], 'question': TRUE_FALSE_PROMPT, 'answer': 'Yes', 'modality': 'image-text', 'metric': 'open-ended', 'question_type': f'image_fake_or_real_{fake_type}_open_ended', 'choices': []})

    return questions_real, questions_fake


def generate_mc_questions2(data, num_questions=100):
    real_images = [image for image in data if not image['is_fake']]
    fake_images = [image for image in data if image['is_fake']]
    
    real_images = random.sample(real_images, num_questions) if len(real_images) > num_questions else real_images
    fake_images = random.sample(fake_images, num_questions) if len(fake_images) > num_questions else fake_images

    questions_real = []
    questions_fake = []
    
    for real_image, fake_image in zip(real_images, fake_images):
        choices_real = [real_image, fake_image]
        random.shuffle(choices_real)
        correct_answer_real = next(i for i, v in enumerate(choices_real) if v['is_fake'])
        
        choices_fake = [real_image, fake_image]
        random.shuffle(choices_fake)
        correct_answer_fake = next(i for i, v in enumerate(choices_fake) if not v['is_fake'])
        
        image_type = real_image['image_type']
    
        questions_real.append({'image_path': [v['image_path'] for v in choices_real], 'question': QUESTION_REAL, 'answer': OPTION_LETTERS[correct_answer_real], 'modality': 'image-text', 'metric': 'multi-choice', 'question_type': f'image_fake_from_real_{image_type}_multi_choice', 'choices': OPTIONS[:2]})
        questions_fake.append({'image_path': [v['image_path'] for v in choices_fake], 'question': QUESTION_FAKE, 'answer': OPTION_LETTERS[correct_answer_fake], 'modality': 'image-text', 'metric': 'multi-choice', 'question_type': f'image_real_from_fake_{image_type}_multi_choice', 'choices': OPTIONS[:2]})

    return questions_real + questions_fake


def generate_mc_questions(data, num_questions=700):
    real_images = [image for image in data if not image['is_fake']]
    fake_images = [image for image in data if image['is_fake']]
    
    # real_images = random.sample(real_images, 100)
    # fake_images = random.sample(fake_images, 100)

    questions_real = []
    questions_fake = []

    for _ in range(num_questions):
        choices_real = random.sample(real_images, 3) + random.sample(fake_images, 1)
        random.shuffle(choices_real)
        correct_answer_real = next(i for i, v in enumerate(choices_real) if v['is_fake'])

        choices_fake = random.sample(fake_images, 3) + random.sample(real_images, 1)
        random.shuffle(choices_fake)
        correct_answer_fake = next(i for i, v in enumerate(choices_fake) if not v['is_fake'])


        questions_real.append({'image_path': [v['image_path'] for v in choices_real], 'question': QUESTION_REAL, 'answer': OPTION_LETTERS[correct_answer_real], 'modality': 'image-text', 'metric': 'multi-choice', 'question_type': 'image_fake_from_real_multi_choice', 'choices': OPTIONS})
        questions_fake.append({'image_path': [v['image_path'] for v in choices_fake], 'question': QUESTION_FAKE, 'answer': OPTION_LETTERS[correct_answer_fake], 'modality': 'image-text', 'metric': 'multi-choice', 'question_type': 'image_real_from_fake_multi_choice', 'choices': OPTIONS})

    return questions_real, questions_fake


def slice_type(data_list):
    type_dict = defaultdict(list)
    for sample in data_list:
        type_dict[sample['image_type']].append(sample)
    
    return type_dict


def count_type(data_list):
    counter = Counter()
    
    for sample in data_list:
        counter[sample['question_type']] += 1
    
    return counter


type_dict = slice_type(data_list)

mc_questions = []

for image_type in type_dict.keys():
    type_data_list = type_dict[image_type]
    mc_questions.extend(generate_mc_questions2(type_data_list))
    

tf_questions_real, tf_questions_fake = generate_tf_questions(data_list)

data_list = tf_questions_real + tf_questions_fake + mc_questions

json.dump(data_list, open('/mnt/petrelfs/zhoubaichuan/projects/synthbench/data/synthbench_image_detection.json', 'w'), indent=4)

print(len(data_list))

print(count_type(data_list))


